package away3dlite.primitives{	import away3dlite.arcane;	import away3dlite.materials.*;	import flash.geom.Vector3D;	use namespace arcane;	/**	 * Creates a 3d geodesic sphere primitive.	 * @see http://wonderfl.net/c/dnOL	 */	public class GeodesicSphere extends AbstractPrimitive	{		private var _radius:Number;		private var _fractures:Number;		private var _yUp:Boolean = true;		/**		 * @inheritDoc		 */		protected override function buildPrimitive():void		{			super.buildPrimitive();			var D2R:Number = Math.PI / 180; //Degree->Radian			var R2D:Number = 180 / Math.PI; //Radian->Degree			var TPI:Number = Math.PI * 2;			var PI:Number = Math.PI;			var HPI:Number = Math.PI / 2;			var hnLat:int = fractures + 1;			var nLat:int = 2 * hnLat;			var nLon:int;			var lon:Number;			var lat:Number;			var dLat:Number = 180 / nLat * D2R;			var dLon:Number;			var i:int;			var j:int;			var x:Number;			var y:Number;			var z:Number;			var sinLat:Number;			var cosLat:Number;			var sinLon:Number;			var cosLon:Number;			var u:Number;			var v:Number;			// Vertex, UVT			// latitude -90->0 : 			x = 0;			y = 0;			z = -_radius;			_yUp ? _vertices.push(x, -z, y) : _vertices.push(x, y, z);			_uvtData.push(0, 0, 1);			for (i = 0; i < hnLat; i++)			{				nLon = 4 * (i + 1); // 4, 8, 12, 16, 20...				dLon = 360 / nLon * D2R;				lat = -HPI + (i + 1) * dLat;				v = (HPI + lat) / PI;				sinLat = Math.sin(lat);				cosLat = Math.cos(lat);				z = radius * sinLat;				for (j = 0; j <= nLon; j++)				{					lon = j * dLon;					sinLon = Math.sin(lon);					cosLon = Math.cos(lon);					x = radius * cosLat * cosLon;					y = radius * cosLat * sinLon;					u = lon / TPI;					_yUp ? _vertices.push(x, -z, y) : _vertices.push(x, y, z);					_uvtData.push(u, v, 1);				}			}			//latitude 0 -> 90			for (i = 1; i < hnLat; i++)			{				nLon = 4 * (hnLat - i);				dLon = 360 / nLon * D2R;				lat = dLat * i;				v = (HPI + lat) / PI;				sinLat = Math.sin(lat);				cosLat = Math.cos(lat);				z = radius * sinLat;				for (j = 0; j <= nLon; j++)				{					lon = j * dLon;					sinLon = Math.sin(lon);					cosLon = Math.cos(lon);					x = radius * cosLat * cosLon;					y = radius * cosLat * sinLon;					u = lon / TPI;					_yUp ? _vertices.push(x, -z, y) : _vertices.push(x, y, z);					_uvtData.push(u, v, 1);				}			}			x = 0;			y = 0;			z = _radius;			_yUp ? _vertices.push(x, -z, y) : _vertices.push(x, y, z);			_uvtData.push(0, 1, 1);			// Face			var k:int;			var pt0:int, pt1:int, pt2:int;			var u_idx_start:int, u_idx_end:int, u_idx:int;			var l_idx_start:int, l_idx_end:int, l_idx:int;			var isUp:int;			var tris:int;			var triIdx:int;			//Latitude -90->0        			tris = 1;			u_idx_start = 0;			u_idx_end = 0;			for (i = 0; i < hnLat; ++i)			{				l_idx_start = u_idx_start;				l_idx_end = u_idx_end;				u_idx_start += 4 * i + 1;				u_idx_end += 4 * (i + 1) + 1;				l_idx = l_idx_start;				u_idx = u_idx_start;				for (k = 0; k < 4; ++k)				{					isUp = 1;					for (triIdx = 0; triIdx < tris; ++triIdx)					{						if (isUp === 1)						{							pt0 = l_idx;							pt2 = u_idx;							u_idx++;							pt1 = u_idx;							isUp = 0;						}						else						{							pt0 = u_idx;							pt1 = l_idx;							l_idx++;							pt2 = l_idx;							isUp = 1;						}						_indices.push(pt0, pt1, pt2);						_faceLengths.push(3);					}				}				tris += 2;			}			//Latitude 0 -> 90         			for (i = hnLat - 1; i >= 0; i--)			{				l_idx_start = u_idx_start;				l_idx_end = u_idx_end;				u_idx_start = u_idx_start + 4 * (i + 1) + 1;				u_idx_end = u_idx_end + 4 * i + 1;				tris -= 2;				u_idx = u_idx_start;				l_idx = l_idx_start;				for (k = 0; k < 4; ++k)				{					isUp = 0;					for (triIdx = 0; triIdx < tris; triIdx++)					{						if (isUp === 1)						{							pt0 = l_idx;							pt2 = u_idx;							u_idx++;							pt1 = u_idx;							isUp = 0;						}						else						{							pt0 = u_idx;							pt1 = l_idx;							l_idx++;							pt2 = l_idx;							isUp = 1;						}						_indices.push(pt0, pt1, pt2);						_faceLengths.push(3);					}				}			}		}		/**		 * Defines the radius of the sphere. Defaults to 100.		 */		public function get radius():Number		{			return _radius;		}		public function set radius(val:Number):void		{			if (_radius == val)				return;			_radius = val;			_primitiveDirty = true;		}		/**		 * Defines the fractures of the sphere. Defaults to 2.		 */		public function get fractures():Number		{			return _fractures;		}		public function set fractures(val:Number):void		{			if (_fractures == val)				return;			_fractures = val;			_primitiveDirty = true;		}		/**		 * Defines whether the coordinates of the plane points use a yUp orientation (true) or a zUp orientation (false). Defaults to true.		 */		public function get yUp():Boolean		{			return _yUp;		}		public function set yUp(val:Boolean):void		{			if (_yUp == val)				return;			_yUp = val;			_primitiveDirty = true;		}		private var n:int = -1;		private function _addFace(v0:Vector3D, v1:Vector3D, v2:Vector3D, uv0:Vector3D, uv1:Vector3D, uv2:Vector3D):void		{			_vertices.push(-v0.x, -v0.y, v0.z, -v1.x, -v1.y, v1.z, -v2.x, -v2.y, v2.z);			_uvtData.push(uv0.x, uv0.y, 1, uv1.x, uv1.y, 1, uv2.x, uv2.y, 1);			n += 3;			_indices.push(n, n - 1, n - 2);			_faceLengths.push(3);		}		private function createUV(u:Number = 0, v:Number = 0):Vector3D		{			return new Vector3D(u, v);		}		private function createVertex(x:Number = 0, y:Number = 0, z:Number = 0):Vector3D		{			return new Vector3D(x, y, z);		}		/**		 * Creates a new <code>GeodesicSphere</code> object.		 *		 * @param	init			[optional]	An initialisation object for specifying default instance properties.		 */		public function GeodesicSphere(material:Material = null, radius:Number = 100, fracture:int = 2, yUp:Boolean = true)		{			super(material);			_radius = radius;			_fractures = fracture;			_yUp = yUp;			type = "GeoSphere";			url = "primitive";		}	}}